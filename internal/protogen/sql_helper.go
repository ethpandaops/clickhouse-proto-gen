// Package protogen handles the generation of Protocol Buffer schemas from ClickHouse tables
package protogen

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/ethpandaops/clickhouse-proto-gen/internal/clickhouse"
)

// GenerateSQLHelpers generates SQL query builder helpers for all tables
func (g *Generator) GenerateSQLHelpers(tables []*clickhouse.Table) error {
	for _, table := range tables {
		if err := g.generateSQLHelper(table); err != nil {
			return err
		}
	}
	// Generate the common SQL helper file
	return g.GenerateSQLCommon()
}

// generateSQLHelper generates the SQL helper file for a single table
func (g *Generator) generateSQLHelper(table *clickhouse.Table) error {
	sb := &strings.Builder{}

	// Write package header
	sb.WriteString("// Code generated by clickhouse-proto-gen. DO NOT EDIT.\n")
	fmt.Fprintf(sb, "// SQL query builder for %s\n\n", table.Name)
	sb.WriteString("package ")

	// Extract package name from go_package
	pkgName := "main"
	if g.config.GoPackage != "" {
		parts := strings.Split(g.config.GoPackage, "/")
		pkgName = parts[len(parts)-1]
		pkgName = strings.ReplaceAll(pkgName, "-", "_")
	}
	sb.WriteString(pkgName)
	sb.WriteString("\n\n")

	// Write imports
	sb.WriteString("import (\n")
	sb.WriteString("\t\"fmt\"\n")
	sb.WriteString(")\n\n")

	// Generate the List SQL builder function
	g.writeSQLBuilderFunction(sb, table)

	// Generate the Get SQL builder function
	g.writeGetSQLBuilderFunction(sb, table)

	// Write to file
	filename := filepath.Join(g.config.OutputDir, fmt.Sprintf("%s.go", table.Name))
	if err := g.writeFile(filename, sb.String()); err != nil {
		return err
	}

	g.log.WithField("file", filename).Info("Generated SQL helper file")
	return nil
}

// getProtocMessageName converts a table name to match protoc's naming conventions
func getProtocMessageName(tableName string) string {
	// Handle table names that start with numbers
	sanitizedTableName := tableName
	if sanitizedTableName != "" && sanitizedTableName[0] >= '0' && sanitizedTableName[0] <= '9' {
		sanitizedTableName = "_" + sanitizedTableName
	}

	// ToPascalCase converts the name
	messageName := ToPascalCase(sanitizedTableName)

	// protoc capitalizes the first letter after digits (e.g., 24h → 24H, 3d → 3D)
	// Handle this pattern throughout the string
	result := []rune(messageName)
	for i := 0; i < len(result)-1; i++ {
		if result[i] >= '0' && result[i] <= '9' && result[i+1] >= 'a' && result[i+1] <= 'z' {
			result[i+1] = result[i+1] - 'a' + 'A' // Convert to uppercase
		}
	}
	return string(result)
}

// writeSQLBuilderFunction generates the SQL query builder function for a List request
func (g *Generator) writeSQLBuilderFunction(sb *strings.Builder, table *clickhouse.Table) {
	messageName := getProtocMessageName(table.Name)
	requestType := fmt.Sprintf("List%sRequest", messageName)

	// Write function signature - now returns SQLQuery and accepts query options
	fmt.Fprintf(sb, "// BuildList%sQuery constructs a parameterized SQL query from a List%sRequest\n", messageName, messageName)
	fmt.Fprintf(sb, "func BuildList%sQuery(req *%s, options ...QueryOption) (SQLQuery, error) {\n", messageName, requestType)

	// Write primary key validation
	primaryKey := table.SortingKey[0]
	primaryKeyField := SanitizeName(primaryKey)

	fmt.Fprintf(sb, "\t// Validate primary key is provided\n")
	fmt.Fprintf(sb, "\tif req.%s == nil {\n", ToPascalCase(primaryKeyField))
	fmt.Fprintf(sb, "\t\treturn SQLQuery{}, fmt.Errorf(\"primary key field %s is required\")\n", primaryKey)
	fmt.Fprintf(sb, "\t}\n\n")

	// Write query building logic with QueryBuilder
	fmt.Fprintf(sb, "\t// Build query using QueryBuilder\n")
	fmt.Fprintf(sb, "\tqb := NewQueryBuilder()\n\n")

	// Get column map for type information
	columnMap := make(map[string]*clickhouse.Column)
	for i := range table.Columns {
		col := &table.Columns[i]
		columnMap[col.Name] = col
	}

	// Process all filters
	g.writeAllFilterConditions(sb, table, columnMap)

	// Build final query
	fmt.Fprintf(sb, "\t// Handle pagination per AIP-132\n")
	fmt.Fprintf(sb, "\tvar limit, offset uint32\n")
	fmt.Fprintf(sb, "\tlimit = 100 // Default page size\n")
	fmt.Fprintf(sb, "\tif req.PageSize > 0 {\n")
	fmt.Fprintf(sb, "\t\tlimit = uint32(req.PageSize)\n")
	fmt.Fprintf(sb, "\t\tif limit > 1000 {\n")
	fmt.Fprintf(sb, "\t\t\tlimit = 1000 // Maximum allowed\n")
	fmt.Fprintf(sb, "\t\t}\n")
	fmt.Fprintf(sb, "\t}\n")
	fmt.Fprintf(sb, "\tif req.PageToken != \"\" {\n")
	fmt.Fprintf(sb, "\t\tdecodedOffset, err := DecodePageToken(req.PageToken)\n")
	fmt.Fprintf(sb, "\t\tif err != nil {\n")
	fmt.Fprintf(sb, "\t\t\treturn SQLQuery{}, fmt.Errorf(\"invalid page_token: %%w\", err)\n")
	fmt.Fprintf(sb, "\t\t}\n")
	fmt.Fprintf(sb, "\t\toffset = decodedOffset\n")
	fmt.Fprintf(sb, "\t}\n\n")

	// Parse order_by field
	fmt.Fprintf(sb, "\t// Handle custom ordering if provided\n")
	fmt.Fprintf(sb, "\tvar orderByClause string\n")
	fmt.Fprintf(sb, "\tif req.OrderBy != \"\" {\n")
	// Get all valid column names for validation
	fmt.Fprintf(sb, "\t\tvalidFields := []string{")
	for i, col := range table.Columns {
		if i > 0 {
			fmt.Fprintf(sb, ", ")
		}
		fmt.Fprintf(sb, "\"%s\"", col.Name)
	}
	fmt.Fprintf(sb, "}\n")
	fmt.Fprintf(sb, "\t\torderFields, err := ParseOrderBy(req.OrderBy, validFields)\n")
	fmt.Fprintf(sb, "\t\tif err != nil {\n")
	fmt.Fprintf(sb, "\t\t\treturn SQLQuery{}, fmt.Errorf(\"invalid order_by: %%w\", err)\n")
	fmt.Fprintf(sb, "\t\t}\n")
	fmt.Fprintf(sb, "\t\torderByClause = BuildOrderByClause(orderFields)\n")
	fmt.Fprintf(sb, "\t} else {\n")
	fmt.Fprintf(sb, "\t\t// Default sorting by primary key\n")
	fmt.Fprintf(sb, "\t\torderByClause = \" ORDER BY ")
	for i, key := range table.SortingKey {
		if i > 0 {
			fmt.Fprintf(sb, " + \", ")
		}
		fmt.Fprintf(sb, "%s\"", key)
	}
	fmt.Fprintf(sb, "\n")
	fmt.Fprintf(sb, "\t}\n\n")

	fmt.Fprintf(sb, "\treturn BuildParameterizedQuery(\"%s\", qb, orderByClause, limit, offset, options...), nil\n", table.Name)
	fmt.Fprintf(sb, "}\n")
}

// writeGetSQLBuilderFunction generates the SQL query builder function for a Get request
func (g *Generator) writeGetSQLBuilderFunction(sb *strings.Builder, table *clickhouse.Table) {
	messageName := getProtocMessageName(table.Name)
	requestType := fmt.Sprintf("Get%sRequest", messageName)

	// Write function signature with query options
	fmt.Fprintf(sb, "\n// BuildGet%sQuery constructs a parameterized SQL query from a Get%sRequest\n", messageName, messageName)
	fmt.Fprintf(sb, "func BuildGet%sQuery(req *%s, options ...QueryOption) (SQLQuery, error) {\n", messageName, requestType)

	// Check if table has sorting keys
	if len(table.SortingKey) == 0 {
		// No sorting key, generate simple query without primary key
		fmt.Fprintf(sb, "\t// Table has no primary key\n")
		fmt.Fprintf(sb, "\tqb := NewQueryBuilder()\n\n")
		fmt.Fprintf(sb, "\t// Return single record\n")
		fmt.Fprintf(sb, "\treturn BuildParameterizedQuery(\"%s\", qb, \"\", 1, 0, options...), nil\n", table.Name)
		fmt.Fprintf(sb, "}\n")
		return
	}

	// Get primary key info
	primaryKey := table.SortingKey[0]
	primaryKeyField := SanitizeName(primaryKey)

	// Find primary key column type
	const (
		stringType  = "string"
		numericType = "numeric"
	)
	var primaryKeyType string
	for _, col := range table.Columns {
		if col.Name == primaryKey {
			protoType, _ := g.typeMapper.MapType(&col)
			// Check if it's a string type
			if protoType == protoString {
				primaryKeyType = stringType
			} else {
				primaryKeyType = numericType
			}
			break
		}
	}

	// Validate primary key is provided based on type
	fmt.Fprintf(sb, "\t// Validate primary key is provided\n")
	if primaryKeyType == stringType {
		fmt.Fprintf(sb, "\tif req.%s == \"\" {\n", ToPascalCase(primaryKeyField))
	} else {
		fmt.Fprintf(sb, "\tif req.%s == 0 {\n", ToPascalCase(primaryKeyField))
	}
	fmt.Fprintf(sb, "\t\treturn SQLQuery{}, fmt.Errorf(\"primary key field %s is required\")\n", primaryKey)
	fmt.Fprintf(sb, "\t}\n\n")

	// Build simple query with primary key
	fmt.Fprintf(sb, "\t// Build query with primary key condition\n")
	fmt.Fprintf(sb, "\tqb := NewQueryBuilder()\n")
	fmt.Fprintf(sb, "\tqb.AddCondition(\"%s\", \"=\", req.%s)\n\n", primaryKey, ToPascalCase(primaryKeyField))

	// Build ORDER BY clause
	fmt.Fprintf(sb, "\t// Build ORDER BY clause\n")
	fmt.Fprintf(sb, "\torderByClause := \" ORDER BY ")
	for i, key := range table.SortingKey {
		if i > 0 {
			fmt.Fprintf(sb, ", ")
		}
		fmt.Fprintf(sb, "%s", key)
	}
	fmt.Fprintf(sb, "\"\n\n")

	// Return query with LIMIT 1
	fmt.Fprintf(sb, "\t// Return single record\n")
	fmt.Fprintf(sb, "\treturn BuildParameterizedQuery(\"%s\", qb, orderByClause, 1, 0, options...), nil\n", table.Name)
	fmt.Fprintf(sb, "}\n")
}

// writeAllFilterConditions writes filter conditions for all columns
func (g *Generator) writeAllFilterConditions(sb *strings.Builder, table *clickhouse.Table, columnMap map[string]*clickhouse.Column) {
	// Process primary key filter
	primaryKey := table.SortingKey[0]
	primaryKeyField := SanitizeName(primaryKey)
	fmt.Fprintf(sb, "\t// Add primary key filter\n")
	g.writeFilterCondition(sb, primaryKey, primaryKeyField, columnMap[primaryKey], true)

	// Process all other columns
	for _, col := range table.Columns {
		// Skip primary key as it's already handled
		if col.Name == primaryKey {
			continue
		}
		fieldName := SanitizeName(col.Name)
		fmt.Fprintf(sb, "\n\t// Add filter for column: %s\n", col.Name)
		g.writeFilterCondition(sb, col.Name, fieldName, &col, false)
	}
	fmt.Fprintf(sb, "\n")
}

// writeFilterCondition generates code to convert a filter to QueryBuilder conditions
func (g *Generator) writeFilterCondition(sb *strings.Builder, columnName, fieldName string, column *clickhouse.Column, isPrimary bool) {
	pascalFieldName := ToPascalCase(fieldName)
	filterType := g.typeMapper.GetFilterTypeForColumn(column)

	if filterType == "" {
		// No filter type for this column, skip
		return
	}

	indent := "\t"
	if !isPrimary {
		// Optional field, check for nil
		fmt.Fprintf(sb, "\tif req.%s != nil {\n", pascalFieldName)
		indent = "\t\t"
	}

	fmt.Fprintf(sb, "%sswitch filter := req.%s.Filter.(type) {\n", indent, pascalFieldName)

	// Handle different filter types based on the column type
	switch {
	case strings.HasPrefix(filterType, "NullableString"):
		g.writeNullableStringFilterCases(sb, columnName, indent)
	case filterType == "StringFilter":
		g.writeStringFilterCases(sb, columnName, indent)
	case strings.HasPrefix(filterType, "NullableUInt32"):
		g.writeNullableNumericFilterCases(sb, columnName, indent, "UInt32")
	case filterType == "UInt32Filter":
		g.writeNumericFilterCases(sb, columnName, indent, "UInt32")
	case strings.HasPrefix(filterType, "NullableUInt64"):
		g.writeNullableNumericFilterCases(sb, columnName, indent, "UInt64")
	case filterType == "UInt64Filter":
		g.writeNumericFilterCases(sb, columnName, indent, "UInt64")
	case strings.HasPrefix(filterType, "NullableInt32"):
		g.writeNullableNumericFilterCases(sb, columnName, indent, "Int32")
	case filterType == "Int32Filter":
		g.writeNumericFilterCases(sb, columnName, indent, "Int32")
	case strings.HasPrefix(filterType, "NullableInt64"):
		g.writeNullableNumericFilterCases(sb, columnName, indent, "Int64")
	case filterType == "Int64Filter":
		g.writeNumericFilterCases(sb, columnName, indent, "Int64")
	}

	// Add default case
	fmt.Fprintf(sb, "%sdefault:\n", indent)
	fmt.Fprintf(sb, "%s\t// Unsupported filter type\n", indent)
	fmt.Fprintf(sb, "%s}\n", indent)

	if !isPrimary {
		fmt.Fprintf(sb, "\t}\n")
	}
}

// writeStringFilterCases generates switch cases for StringFilter using QueryBuilder
func (g *Generator) writeStringFilterCases(sb *strings.Builder, columnName, indent string) {
	fmt.Fprintf(sb, "%scase *StringFilter_Eq:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_Ne:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_Contains:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.Contains + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_StartsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.StartsWith + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_EndsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.EndsWith)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_Like:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.Like)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_NotLike:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddNotLikeCondition(\"%s\", filter.NotLike)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_In:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", StringSliceToInterface(filter.In.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *StringFilter_NotIn:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", StringSliceToInterface(filter.NotIn.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)
}

// writeNullableStringFilterCases generates switch cases for NullableStringFilter using QueryBuilder
func (g *Generator) writeNullableStringFilterCases(sb *strings.Builder, columnName, indent string) {
	// Nullable string filter cases
	fmt.Fprintf(sb, "%scase *NullableStringFilter_Eq:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_Ne:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_Contains:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.Contains + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_StartsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.StartsWith + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_EndsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.EndsWith)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_Like:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.Like)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_NotLike:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddNotLikeCondition(\"%s\", filter.NotLike)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_In:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", StringSliceToInterface(filter.In.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_NotIn:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", StringSliceToInterface(filter.NotIn.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	// Plus null cases
	fmt.Fprintf(sb, "%scase *NullableStringFilter_IsNull:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddIsNullCondition(\"%s\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_IsNotNull:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddIsNotNullCondition(\"%s\")\n", indent, columnName)
}

// writeNumericFilterCases generates switch cases for numeric filters using QueryBuilder
func (g *Generator) writeNumericFilterCases(sb *strings.Builder, columnName, indent, typeName string) {
	// typeName is already correctly cased (e.g., "UInt32", "Int64")
	typePrefix := typeName
	fmt.Fprintf(sb, "%scase *%sFilter_Eq:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Ne:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", filter.Lt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", filter.Lte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", filter.Gt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", filter.Gte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Between:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", filter.Between.Min, filter.Between.Max)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_In:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", %sSliceToInterface(filter.In.Values))\n", indent, columnName, typePrefix)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *%sFilter_NotIn:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", %sSliceToInterface(filter.NotIn.Values))\n", indent, columnName, typePrefix)
	fmt.Fprintf(sb, "%s\t}\n", indent)
}

// writeNullableNumericFilterCases generates switch cases for nullable numeric filters
func (g *Generator) writeNullableNumericFilterCases(sb *strings.Builder, columnName, indent, typeName string) {
	// typeName is already correctly cased (e.g., "UInt32", "Int64")
	typePrefix := "Nullable" + typeName

	// Generate all the numeric filter cases with Nullable prefix
	fmt.Fprintf(sb, "%scase *%sFilter_Eq:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Ne:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", filter.Lt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", filter.Lte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", filter.Gt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", filter.Gte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Between:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", filter.Between.Min, filter.Between.Max)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_In:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", %sSliceToInterface(filter.In.Values))\n", indent, columnName, typeName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *%sFilter_NotIn:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", %sSliceToInterface(filter.NotIn.Values))\n", indent, columnName, typeName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	// Plus null cases
	fmt.Fprintf(sb, "%scase *%sFilter_IsNull:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddIsNullCondition(\"%s\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_IsNotNull:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddIsNotNullCondition(\"%s\")\n", indent, columnName)
}
