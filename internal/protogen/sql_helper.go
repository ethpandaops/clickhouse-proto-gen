// Package protogen handles the generation of Protocol Buffer schemas from ClickHouse tables
package protogen

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"

	"github.com/ethpandaops/clickhouse-proto-gen/internal/clickhouse"
	"github.com/ethpandaops/clickhouse-proto-gen/internal/config"
)

const (
	clickhouseDateTime   = "DateTime"
	clickhouseDateTime64 = "DateTime64"
	clickhouseDate       = "Date"
	clickhouseDate32     = "Date32"
	clickhouseUInt8      = "UInt8"
	clickhouseUInt16     = "UInt16"
	clickhouseDecimal    = "Decimal"
	clickhouseDecimal32  = "Decimal32"
	clickhouseDecimal64  = "Decimal64"
	clickhouseDecimal128 = "Decimal128"
	clickhouseDecimal256 = "Decimal256"
)

// GenerateSQLHelpers generates SQL query builder helpers for all tables
func (g *Generator) GenerateSQLHelpers(tables []*clickhouse.Table) error {
	for _, table := range tables {
		// Skip tables with no columns (likely non-existent or failed to load)
		if len(table.Columns) == 0 {
			g.log.WithField("table", table.Name).Warn("Skipping SQL helper generation for table with no columns")
			continue
		}
		// Skip tables without sorting keys (no service/request types generated for them)
		if len(table.SortingKey) == 0 {
			g.log.WithField("table", table.Name).Debug("Skipping SQL helper generation for table without sorting key")
			continue
		}
		if err := g.generateSQLHelper(table); err != nil {
			return err
		}
	}
	// Generate the common SQL helper file
	return g.GenerateSQLCommon()
}

// generateSQLHelper generates the SQL helper file for a single table
func (g *Generator) generateSQLHelper(table *clickhouse.Table) error {
	sb := &strings.Builder{}

	// Write package header
	sb.WriteString("// Code generated by clickhouse-proto-gen. DO NOT EDIT.\n")
	fmt.Fprintf(sb, "// SQL query builder for %s\n\n", table.Name)
	sb.WriteString("package ")

	// Extract package name from go_package
	pkgName := "main"
	if g.config.GoPackage != "" {
		parts := strings.Split(g.config.GoPackage, "/")
		pkgName = parts[len(parts)-1]
		pkgName = strings.ReplaceAll(pkgName, "-", "_")
	}
	sb.WriteString(pkgName)
	sb.WriteString("\n\n")

	// Write imports
	sb.WriteString("import (\n")
	sb.WriteString("\t\"fmt\"\n")
	sb.WriteString(")\n\n")

	// Generate the List SQL builder function
	g.writeSQLBuilderFunction(sb, table)

	// Generate the Get SQL builder function
	g.writeGetSQLBuilderFunction(sb, table)

	// Write to file
	filename := filepath.Join(g.config.OutputDir, fmt.Sprintf("%s.go", table.Name))
	if err := g.writeFile(filename, sb.String()); err != nil {
		return err
	}

	g.log.WithField("file", filename).Info("Generated SQL helper file")
	return nil
}

// getProtocMessageName converts a table name to match protoc's naming conventions
func getProtocMessageName(tableName string) string {
	// Handle table names that start with numbers
	sanitizedTableName := tableName
	if sanitizedTableName != "" && sanitizedTableName[0] >= '0' && sanitizedTableName[0] <= '9' {
		sanitizedTableName = "_" + sanitizedTableName
	}

	// ToPascalCase converts the name
	messageName := ToPascalCase(sanitizedTableName)

	// protoc capitalizes the first letter after digits (e.g., 24h → 24H, 3d → 3D)
	// Handle this pattern throughout the string
	result := []rune(messageName)
	for i := 0; i < len(result)-1; i++ {
		if result[i] >= '0' && result[i] <= '9' && result[i+1] >= 'a' && result[i+1] <= 'z' {
			result[i+1] = result[i+1] - 'a' + 'A' // Convert to uppercase
		}
	}
	return string(result)
}

// needsStringConversion checks if a column type requires toString() conversion.
// Large integer types (UInt128, UInt256, Int128, Int256) are too large for
// standard Go integer types and are mapped to string in protobuf.
func needsStringConversion(col *clickhouse.Column) bool {
	largeIntTypes := []string{"UInt128", "UInt256", "Int128", "Int256"}
	for _, t := range largeIntTypes {
		if col.BaseType == t {
			return true
		}
	}
	return false
}

// hasNullableArrayElements checks if an array column has nullable elements.
// Example: Array(Nullable(UInt64)) returns true, Array(UInt64) returns false.
func hasNullableArrayElements(col *clickhouse.Column) bool {
	if !col.IsArray {
		return false
	}
	return strings.Contains(col.Type, "Array(Nullable(")
}

// getDefaultValueForType returns the appropriate default value for a type to use with coalesce().
func getDefaultValueForType(baseType string) string {
	// For numeric types, default to 0
	numericTypes := []string{
		"UInt8", "UInt16", "UInt32", typeUInt64, "UInt128", "UInt256",
		"Int8", "Int16", "Int32", "Int64", "Int128", "Int256",
		"Float32", "Float64",
		"Decimal", "Decimal32", "Decimal64", "Decimal128", "Decimal256",
	}
	for _, t := range numericTypes {
		if strings.HasPrefix(baseType, t) {
			return "0"
		}
	}

	// For DateTime types, default to 0 (Unix epoch)
	if strings.HasPrefix(baseType, "DateTime") {
		return "0"
	}

	// For Date types, default to epoch date
	if baseType == "Date" || baseType == "Date32" {
		return "'1970-01-01'"
	}

	// For string types, default to empty string
	return "''"
}

// getSelectColumnExpression generates the appropriate SELECT column expression
// based on the column's type. DateTime types are wrapped with transformation
// functions to return Unix timestamps. Large integer types are wrapped with
// toString() to convert them to strings for protobuf compatibility.
// UInt8/UInt16 are converted to UInt32, and Date/Date32 are converted to string.
// Arrays with nullable elements are wrapped with coalesce() to replace NULLs.
// FixedString fields with zero bytes are converted to NULL.
//
//nolint:gocyclo // High complexity is inherent to type mapping logic
func getSelectColumnExpression(col *clickhouse.Column, tableName string, convConfig *config.ConversionConfig) string {
	hasNullable := hasNullableArrayElements(col)

	// PRIORITY 1: Check if this Int64/UInt64 should be converted to string for JavaScript precision
	if (col.BaseType == typeUInt64 || col.BaseType == typeInt64) && convConfig.ShouldConvertToString(tableName, col.Name) {
		if col.IsArray {
			if hasNullable {
				// Array(Nullable(Int64/UInt64)) → Array(String) with NULL handling
				return fmt.Sprintf("arrayMap(x -> toString(coalesce(x, 0)), `%s`) AS `%s`", col.Name, col.Name)
			}
			// Array(Int64/UInt64) → Array(String)
			return fmt.Sprintf("arrayMap(x -> toString(x), `%s`) AS `%s`", col.Name, col.Name)
		}
		// Regular Int64/UInt64 → String
		return fmt.Sprintf("toString(`%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle FixedString types - convert zero-byte strings to NULL
	// This prevents confusing zero-byte string output in API responses
	// Check BaseType first (handles Nullable(FixedString(N))), then parse full Type for length
	if col.BaseType == "FixedString" {
		if isFixed, length := IsFixedString(col.Type); isFixed {
			return fmt.Sprintf("NULLIF(`%s`, repeat('\\x00', %d)) AS `%s`", col.Name, length, col.Name)
		}
	}

	// Handle Array(DateTime) types with arrayMap transformation
	if col.IsArray && col.BaseType == clickhouseDateTime {
		if hasNullable {
			defVal := getDefaultValueForType(col.BaseType)
			return fmt.Sprintf("arrayMap(x -> toUnixTimestamp(coalesce(x, %s)), `%s`) AS `%s`", defVal, col.Name, col.Name)
		}
		return fmt.Sprintf("arrayMap(x -> toUnixTimestamp(x), `%s`) AS `%s`", col.Name, col.Name)
	}
	if col.IsArray && col.BaseType == clickhouseDateTime64 {
		if hasNullable {
			defVal := getDefaultValueForType(col.BaseType)
			return fmt.Sprintf("arrayMap(x -> toUnixTimestamp64Micro(coalesce(x, %s)), `%s`) AS `%s`", defVal, col.Name, col.Name)
		}
		return fmt.Sprintf("arrayMap(x -> toUnixTimestamp64Micro(x), `%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle Array(Date) and Array(Date32) types with arrayMap transformation
	if col.IsArray && (col.BaseType == clickhouseDate || col.BaseType == clickhouseDate32) {
		if hasNullable {
			defVal := getDefaultValueForType(col.BaseType)
			return fmt.Sprintf("arrayMap(x -> toString(coalesce(x, %s)), `%s`) AS `%s`", defVal, col.Name, col.Name)
		}
		return fmt.Sprintf("arrayMap(x -> toString(x), `%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle Array(UInt8) and Array(UInt16) types with arrayMap transformation
	if col.IsArray && (col.BaseType == clickhouseUInt8 || col.BaseType == clickhouseUInt16) {
		if hasNullable {
			return fmt.Sprintf("arrayMap(x -> toUInt32(coalesce(x, 0)), `%s`) AS `%s`", col.Name, col.Name)
		}
		return fmt.Sprintf("arrayMap(x -> toUInt32(x), `%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle regular DateTime types
	if col.BaseType == clickhouseDateTime {
		return fmt.Sprintf("toUnixTimestamp(`%s`) AS `%s`", col.Name, col.Name)
	}
	if col.BaseType == clickhouseDateTime64 {
		return fmt.Sprintf("toUnixTimestamp64Micro(`%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle Date and Date32 types (convert to string for Go scanning)
	if col.BaseType == clickhouseDate || col.BaseType == clickhouseDate32 {
		return fmt.Sprintf("toString(`%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle UInt8 and UInt16 types (convert to UInt32 for Go scanning)
	if col.BaseType == clickhouseUInt8 || col.BaseType == clickhouseUInt16 {
		return fmt.Sprintf("toUInt32(`%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle Decimal types (convert to string to preserve precision)
	if col.BaseType == clickhouseDecimal || col.BaseType == clickhouseDecimal32 ||
		col.BaseType == clickhouseDecimal64 || col.BaseType == clickhouseDecimal128 ||
		col.BaseType == clickhouseDecimal256 {
		if col.IsArray {
			if hasNullable {
				return fmt.Sprintf("arrayMap(x -> toString(coalesce(x, 0)), `%s`) AS `%s`", col.Name, col.Name)
			}
			return fmt.Sprintf("arrayMap(x -> toString(x), `%s`) AS `%s`", col.Name, col.Name)
		}
		return fmt.Sprintf("toString(`%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle large integer types that need string conversion
	if needsStringConversion(col) {
		if col.IsArray {
			if hasNullable {
				return fmt.Sprintf("arrayMap(x -> toString(coalesce(x, 0)), `%s`) AS `%s`", col.Name, col.Name)
			}
			return fmt.Sprintf("arrayMap(x -> toString(x), `%s`) AS `%s`", col.Name, col.Name)
		}
		return fmt.Sprintf("toString(`%s`) AS `%s`", col.Name, col.Name)
	}

	// Handle any remaining arrays with nullable elements that don't need type conversion
	// but still need NULL handling (e.g., Array(Nullable(UInt64)))
	if col.IsArray && hasNullable {
		defVal := getDefaultValueForType(col.BaseType)
		return fmt.Sprintf("arrayMap(x -> coalesce(x, %s), `%s`) AS `%s`", defVal, col.Name, col.Name)
	}

	// Default: return column name as-is
	return col.Name
}

// writeSQLBuilderFunction generates the SQL query builder function for a List request
func (g *Generator) writeSQLBuilderFunction(sb *strings.Builder, table *clickhouse.Table) {
	messageName := getProtocMessageName(table.Name)
	requestType := fmt.Sprintf("List%sRequest", messageName)

	// Write function signature - now returns SQLQuery and accepts query options
	fmt.Fprintf(sb, "// BuildList%sQuery constructs a parameterized SQL query from a List%sRequest\n", messageName, messageName)
	if len(table.Projections) > 0 {
		fmt.Fprintf(sb, "//\n")
		fmt.Fprintf(sb, "// Available projections:\n")
		for _, proj := range table.Projections {
			if len(proj.OrderByKey) > 0 {
				fmt.Fprintf(sb, "//   - %s (primary key: %s)\n", proj.Name, proj.OrderByKey[0])
			} else {
				fmt.Fprintf(sb, "//   - %s\n", proj.Name)
			}
		}
		fmt.Fprintf(sb, "//\n")
		fmt.Fprintf(sb, "// Use WithProjection() option to select a specific projection.\n")
	}
	fmt.Fprintf(sb, "func BuildList%sQuery(req *%s, options ...QueryOption) (SQLQuery, error) {\n", messageName, requestType)

	// Write primary key validation - check base table and projections
	g.writePrimaryKeyValidation(sb, table)

	// Write query building logic with QueryBuilder
	fmt.Fprintf(sb, "\t// Build query using QueryBuilder\n")
	fmt.Fprintf(sb, "\tqb := NewQueryBuilder()\n\n")

	// Get column map for type information
	columnMap := make(map[string]*clickhouse.Column)
	for i := range table.Columns {
		col := &table.Columns[i]
		columnMap[col.Name] = col
	}

	// Process all filters
	g.writeAllFilterConditions(sb, table, columnMap)

	// Build final query
	fmt.Fprintf(sb, "\t// Handle pagination per AIP-132\n")
	fmt.Fprintf(sb, "\t// Validate page size\n")
	fmt.Fprintf(sb, "\tif req.PageSize < 0 {\n")
	fmt.Fprintf(sb, "\t\treturn SQLQuery{}, fmt.Errorf(\"page_size must be non-negative, got %%d\", req.PageSize)\n")
	fmt.Fprintf(sb, "\t}\n")
	fmt.Fprintf(sb, "\tif req.PageSize > %d {\n", g.config.MaxPageSize)
	fmt.Fprintf(sb, "\t\treturn SQLQuery{}, fmt.Errorf(\"page_size must not exceed %%d, got %%d\", %d, req.PageSize)\n", g.config.MaxPageSize)
	fmt.Fprintf(sb, "\t}\n\n")
	fmt.Fprintf(sb, "\tvar limit, offset uint32\n")
	fmt.Fprintf(sb, "\tlimit = 100 // Default page size\n")
	fmt.Fprintf(sb, "\tif req.PageSize > 0 {\n")
	fmt.Fprintf(sb, "\t\tlimit = uint32(req.PageSize)\n")
	fmt.Fprintf(sb, "\t}\n")
	fmt.Fprintf(sb, "\tif req.PageToken != \"\" {\n")
	fmt.Fprintf(sb, "\t\tdecodedOffset, err := DecodePageToken(req.PageToken)\n")
	fmt.Fprintf(sb, "\t\tif err != nil {\n")
	fmt.Fprintf(sb, "\t\t\treturn SQLQuery{}, fmt.Errorf(\"invalid page_token: %%w\", err)\n")
	fmt.Fprintf(sb, "\t\t}\n")
	fmt.Fprintf(sb, "\t\toffset = decodedOffset\n")
	fmt.Fprintf(sb, "\t}\n\n")

	// Parse order_by field
	fmt.Fprintf(sb, "\t// Handle custom ordering if provided\n")
	fmt.Fprintf(sb, "\tvar orderByClause string\n")
	fmt.Fprintf(sb, "\tif req.OrderBy != \"\" {\n")
	// Get all valid column names for validation
	fmt.Fprintf(sb, "\t\tvalidFields := []string{")
	for i, col := range table.Columns {
		if i > 0 {
			fmt.Fprintf(sb, ", ")
		}
		fmt.Fprintf(sb, "\"%s\"", col.Name)
	}
	fmt.Fprintf(sb, "}\n")
	fmt.Fprintf(sb, "\t\torderFields, err := ParseOrderBy(req.OrderBy, validFields)\n")
	fmt.Fprintf(sb, "\t\tif err != nil {\n")
	fmt.Fprintf(sb, "\t\t\treturn SQLQuery{}, fmt.Errorf(\"invalid order_by: %%w\", err)\n")
	fmt.Fprintf(sb, "\t\t}\n")
	fmt.Fprintf(sb, "\t\torderByClause = BuildOrderByClause(orderFields)\n")
	fmt.Fprintf(sb, "\t} else {\n")
	if len(table.SortingKey) > 0 {
		fmt.Fprintf(sb, "\t\t// Default sorting by primary key\n")
		fmt.Fprintf(sb, "\t\torderByClause = \" ORDER BY ")
		for i, key := range table.SortingKey {
			if i > 0 {
				fmt.Fprintf(sb, " + \", ")
			}
			fmt.Fprintf(sb, "%s\"", key)
		}
		fmt.Fprintf(sb, "\n")
	} else {
		fmt.Fprintf(sb, "\t\t// No default sorting (table has no primary key)\n")
		fmt.Fprintf(sb, "\t\torderByClause = \"\"\n")
	}
	fmt.Fprintf(sb, "\t}\n\n")

	// Build column list for explicit selection
	fmt.Fprintf(sb, "\t// Build column list\n")
	fmt.Fprintf(sb, "\tcolumns := []string{")
	for i, col := range table.Columns {
		if i > 0 {
			fmt.Fprintf(sb, ", ")
		}
		colExpr := getSelectColumnExpression(&col, table.Name, &g.config.Conversion)
		fmt.Fprintf(sb, "\"%s\"", colExpr)
	}
	fmt.Fprintf(sb, "}\n\n")
	fmt.Fprintf(sb, "\treturn BuildParameterizedQuery(\"%s\", columns, qb, orderByClause, limit, offset, options...)\n", table.Name)
	fmt.Fprintf(sb, "}\n")
}

// writePrimaryKeyValidation writes validation to ensure at least one primary key is provided
func (g *Generator) writePrimaryKeyValidation(sb *strings.Builder, table *clickhouse.Table) {
	// Collect all primary keys from base table and projections
	allPrimaryKeys := make(map[string]bool)

	// Add base table primary key if exists
	if len(table.SortingKey) > 0 {
		allPrimaryKeys[table.SortingKey[0]] = true
	}

	// Add projection primary keys (first column in ORDER BY)
	for _, proj := range table.Projections {
		if len(proj.OrderByKey) > 0 {
			allPrimaryKeys[proj.OrderByKey[0]] = true
		}
	}

	if len(allPrimaryKeys) == 0 {
		// No primary keys at all, no validation needed
		return
	}

	// Create a sorted list of keys for deterministic output
	keyNames := make([]string, 0, len(allPrimaryKeys))
	for key := range allPrimaryKeys {
		keyNames = append(keyNames, key)
	}
	sort.Strings(keyNames)

	fmt.Fprintf(sb, "\t// Validate that at least one primary key is provided\n")
	fmt.Fprintf(sb, "\t// Primary keys can come from base table or projections\n")

	// Build the validation condition with sorted keys
	conditions := make([]string, 0, len(keyNames))
	for _, key := range keyNames {
		fieldName := SanitizeName(key)
		conditions = append(conditions, fmt.Sprintf("req.%s == nil", ToPascalCase(fieldName)))
	}

	if len(conditions) == 1 {
		// Only one primary key exists
		fmt.Fprintf(sb, "\tif %s {\n", conditions[0])
		fmt.Fprintf(sb, "\t\treturn SQLQuery{}, fmt.Errorf(\"primary key field %s is required\")\n", keyNames[0])
	} else {
		// Multiple primary keys exist, at least one must be provided
		fmt.Fprintf(sb, "\tif %s {\n", strings.Join(conditions, " && "))
		fmt.Fprintf(sb, "\t\treturn SQLQuery{}, fmt.Errorf(\"at least one primary key field is required: %s\")\n", strings.Join(keyNames, ", "))
	}
	fmt.Fprintf(sb, "\t}\n\n")
}

// writeGetSQLBuilderFunction generates the SQL query builder function for a Get request
func (g *Generator) writeGetSQLBuilderFunction(sb *strings.Builder, table *clickhouse.Table) {
	messageName := getProtocMessageName(table.Name)
	requestType := fmt.Sprintf("Get%sRequest", messageName)

	// Write function signature with query options
	fmt.Fprintf(sb, "\n// BuildGet%sQuery constructs a parameterized SQL query from a Get%sRequest\n", messageName, messageName)
	fmt.Fprintf(sb, "func BuildGet%sQuery(req *%s, options ...QueryOption) (SQLQuery, error) {\n", messageName, requestType)

	// Check if table has sorting keys
	if len(table.SortingKey) == 0 {
		// No sorting key, generate simple query without primary key
		fmt.Fprintf(sb, "\t// Table has no primary key\n")
		fmt.Fprintf(sb, "\tqb := NewQueryBuilder()\n\n")
		// Build column list for explicit selection
		fmt.Fprintf(sb, "\t// Build column list\n")
		fmt.Fprintf(sb, "\tcolumns := []string{")
		for i, col := range table.Columns {
			if i > 0 {
				fmt.Fprintf(sb, ", ")
			}
			colExpr := getSelectColumnExpression(&col, table.Name, &g.config.Conversion)
			fmt.Fprintf(sb, "\"%s\"", colExpr)
		}
		fmt.Fprintf(sb, "}\n\n")
		fmt.Fprintf(sb, "\t// Return single record\n")
		fmt.Fprintf(sb, "\treturn BuildParameterizedQuery(\"%s\", columns, qb, \"\", 1, 0, options...)\n", table.Name)
		fmt.Fprintf(sb, "}\n")
		return
	}

	// Get primary key info
	primaryKey := table.SortingKey[0]
	primaryKeyField := SanitizeName(primaryKey)

	// Find primary key column type
	const (
		stringType  = "string"
		numericType = "numeric"
	)
	var primaryKeyType string
	for _, col := range table.Columns {
		if col.Name == primaryKey {
			protoType, _ := g.typeMapper.MapType(&col, table.Name, &g.config.Conversion)
			// Check if it's a string type
			if protoType == protoString {
				primaryKeyType = stringType
			} else {
				primaryKeyType = numericType
			}
			break
		}
	}

	// Validate primary key is provided based on type
	fmt.Fprintf(sb, "\t// Validate primary key is provided\n")
	if primaryKeyType == stringType {
		fmt.Fprintf(sb, "\tif req.%s == \"\" {\n", ToPascalCase(primaryKeyField))
	} else {
		fmt.Fprintf(sb, "\tif req.%s == 0 {\n", ToPascalCase(primaryKeyField))
	}
	fmt.Fprintf(sb, "\t\treturn SQLQuery{}, fmt.Errorf(\"primary key field %s is required\")\n", primaryKey)
	fmt.Fprintf(sb, "\t}\n\n")

	// Build simple query with primary key
	fmt.Fprintf(sb, "\t// Build query with primary key condition\n")
	fmt.Fprintf(sb, "\tqb := NewQueryBuilder()\n")
	fmt.Fprintf(sb, "\tqb.AddCondition(\"%s\", \"=\", req.%s)\n\n", primaryKey, ToPascalCase(primaryKeyField))

	// Build ORDER BY clause
	fmt.Fprintf(sb, "\t// Build ORDER BY clause\n")
	fmt.Fprintf(sb, "\torderByClause := \" ORDER BY ")
	for i, key := range table.SortingKey {
		if i > 0 {
			fmt.Fprintf(sb, ", ")
		}
		fmt.Fprintf(sb, "%s", key)
	}
	fmt.Fprintf(sb, "\"\n\n")

	// Build column list for explicit selection
	fmt.Fprintf(sb, "\t// Build column list\n")
	fmt.Fprintf(sb, "\tcolumns := []string{")
	for i, col := range table.Columns {
		if i > 0 {
			fmt.Fprintf(sb, ", ")
		}
		colExpr := getSelectColumnExpression(&col, table.Name, &g.config.Conversion)
		fmt.Fprintf(sb, "\"%s\"", colExpr)
	}
	fmt.Fprintf(sb, "}\n\n")

	// Return query with LIMIT 1
	fmt.Fprintf(sb, "\t// Return single record\n")
	fmt.Fprintf(sb, "\treturn BuildParameterizedQuery(\"%s\", columns, qb, orderByClause, 1, 0, options...)\n", table.Name)
	fmt.Fprintf(sb, "}\n")
}

// writeAllFilterConditions writes filter conditions for all columns
func (g *Generator) writeAllFilterConditions(sb *strings.Builder, table *clickhouse.Table, columnMap map[string]*clickhouse.Column) {
	// Collect all primary keys from base table and projections
	allPrimaryKeys := make(map[string]bool)
	if len(table.SortingKey) > 0 {
		allPrimaryKeys[table.SortingKey[0]] = true
	}
	for _, proj := range table.Projections {
		if len(proj.OrderByKey) > 0 {
			allPrimaryKeys[proj.OrderByKey[0]] = true
		}
	}

	// If multiple primary keys exist (from projections), treat all as optional
	// Only when there's a single primary key should it be treated as required
	hasMultiplePrimaryKeys := len(allPrimaryKeys) > 1

	// Check if table has a primary key
	var primaryKey string
	if len(table.SortingKey) > 0 {
		// Process primary key filter
		primaryKey = table.SortingKey[0]
		primaryKeyField := SanitizeName(primaryKey)
		fmt.Fprintf(sb, "\t// Add primary key filter\n")
		// If multiple primary keys exist, treat this one as optional too
		isPrimary := !hasMultiplePrimaryKeys
		g.writeFilterCondition(sb, table, primaryKey, primaryKeyField, columnMap[primaryKey], isPrimary)
	}

	// Process all other columns
	for _, col := range table.Columns {
		// Skip primary key as it's already handled
		if primaryKey != "" && col.Name == primaryKey {
			continue
		}
		fieldName := SanitizeName(col.Name)
		fmt.Fprintf(sb, "\n\t// Add filter for column: %s\n", col.Name)
		g.writeFilterCondition(sb, table, col.Name, fieldName, &col, false)
	}
	fmt.Fprintf(sb, "\n")
}

// writeFilterCondition generates code to convert a filter to QueryBuilder conditions
func (g *Generator) writeFilterCondition(sb *strings.Builder, table *clickhouse.Table, columnName, fieldName string, column *clickhouse.Column, isPrimary bool) {
	pascalFieldName := ToPascalCase(fieldName)
	filterType := g.typeMapper.GetFilterTypeForColumn(column, table.Name, &g.config.Conversion)

	if filterType == "" {
		// No filter type for this column, skip
		return
	}

	// Check if this is a DateTime column
	isDateTime := column.BaseType == clickhouseDateTime || column.BaseType == clickhouseDateTime64

	indent := "\t"
	if !isPrimary {
		// Optional field, check for nil
		fmt.Fprintf(sb, "\tif req.%s != nil {\n", pascalFieldName)
		indent = "\t\t"
	}

	fmt.Fprintf(sb, "%sswitch filter := req.%s.Filter.(type) {\n", indent, pascalFieldName)

	// Write filter cases based on type
	if isDateTime {
		// For DateTime columns, we need special handling
		g.writeDateTimeFilterCases(sb, columnName, filterType, indent)
	} else {
		g.writeFilterCases(sb, columnName, filterType, indent)
	}

	// Add default case
	fmt.Fprintf(sb, "%sdefault:\n", indent)
	fmt.Fprintf(sb, "%s\t// Unsupported filter type\n", indent)
	fmt.Fprintf(sb, "%s}\n", indent)

	if !isPrimary {
		fmt.Fprintf(sb, "\t}\n")
	}
}

// handleNumericFilter handles numeric filter types
func (g *Generator) handleNumericFilter(sb *strings.Builder, columnName, filterType, indent string) {
	isNullable := strings.HasPrefix(filterType, "Nullable")
	numericType := strings.TrimPrefix(filterType, "Nullable")
	numericType = strings.TrimSuffix(numericType, "Filter")

	if isNullable {
		g.writeNullableNumericFilterCases(sb, columnName, indent, numericType)
	} else {
		g.writeNumericFilterCases(sb, columnName, indent, numericType)
	}
}

// handleMapFilter handles Map filter types
func (g *Generator) handleMapFilter(sb *strings.Builder, columnName, filterType, indent string) {
	if filterType == "MapStringStringFilter" {
		g.writeMapStringStringFilterCases(sb, columnName, indent)
		return
	}

	// Extract numeric type from MapString<Type>Filter
	if strings.HasPrefix(filterType, "MapString") && strings.HasSuffix(filterType, "Filter") {
		numericType := strings.TrimPrefix(filterType, "MapString")
		numericType = strings.TrimSuffix(numericType, "Filter")
		g.writeMapStringNumericFilterCases(sb, columnName, indent, numericType)
	}
}

// writeFilterCases writes the appropriate filter cases based on the filter type
func (g *Generator) writeFilterCases(sb *strings.Builder, columnName, filterType, indent string) {
	// Handle string filters
	if strings.Contains(filterType, "String") && !strings.HasPrefix(filterType, "Map") {
		if strings.HasPrefix(filterType, "Nullable") {
			g.writeNullableStringFilterCases(sb, columnName, indent)
		} else {
			g.writeStringFilterCases(sb, columnName, indent)
		}
		return
	}

	// Handle boolean filters
	if strings.Contains(filterType, "Bool") {
		if strings.HasPrefix(filterType, "Nullable") {
			g.writeNullableBoolFilterCases(sb, columnName, indent)
		} else {
			g.writeBoolFilterCases(sb, columnName, indent)
		}
		return
	}

	// Handle Map filters
	if strings.HasPrefix(filterType, "Map") {
		g.handleMapFilter(sb, columnName, filterType, indent)
		return
	}

	// Handle numeric filters (Int32, Int64, UInt32, UInt64)
	if strings.Contains(filterType, "Int32") || strings.Contains(filterType, "Int64") ||
		strings.Contains(filterType, "UInt32") || strings.Contains(filterType, typeUInt64) {
		g.handleNumericFilter(sb, columnName, filterType, indent)
	}
}

// writeStringFilterCases generates switch cases for StringFilter using QueryBuilder
func (g *Generator) writeStringFilterCases(sb *strings.Builder, columnName, indent string) {
	fmt.Fprintf(sb, "%scase *StringFilter_Eq:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_Ne:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_Contains:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.Contains + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_StartsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.StartsWith + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_EndsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.EndsWith)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_Like:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.Like)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_NotLike:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddNotLikeCondition(\"%s\", filter.NotLike)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *StringFilter_In:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", StringSliceToInterface(filter.In.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *StringFilter_NotIn:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", StringSliceToInterface(filter.NotIn.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)
}

// writeNullableStringFilterCases generates switch cases for NullableStringFilter using QueryBuilder
func (g *Generator) writeNullableStringFilterCases(sb *strings.Builder, columnName, indent string) {
	// Nullable string filter cases
	fmt.Fprintf(sb, "%scase *NullableStringFilter_Eq:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_Ne:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_Contains:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.Contains + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_StartsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.StartsWith + \"%%\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_EndsWith:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", \"%%\" + filter.EndsWith)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_Like:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddLikeCondition(\"%s\", filter.Like)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_NotLike:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddNotLikeCondition(\"%s\", filter.NotLike)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_In:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", StringSliceToInterface(filter.In.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_NotIn:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", StringSliceToInterface(filter.NotIn.Values))\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	// Plus null cases
	fmt.Fprintf(sb, "%scase *NullableStringFilter_IsNull:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddIsNullCondition(\"%s\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableStringFilter_IsNotNull:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddIsNotNullCondition(\"%s\")\n", indent, columnName)
}

// writeNumericFilterCases generates switch cases for numeric filters using QueryBuilder
func (g *Generator) writeNumericFilterCases(sb *strings.Builder, columnName, indent, typeName string) {
	// typeName is already correctly cased (e.g., "UInt32", "Int64")
	typePrefix := typeName
	fmt.Fprintf(sb, "%scase *%sFilter_Eq:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Ne:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", filter.Lt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", filter.Lte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", filter.Gt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", filter.Gte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Between:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", filter.Between.Min, filter.Between.Max.GetValue())\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_In:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", %sSliceToInterface(filter.In.Values))\n", indent, columnName, typePrefix)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *%sFilter_NotIn:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", %sSliceToInterface(filter.NotIn.Values))\n", indent, columnName, typePrefix)
	fmt.Fprintf(sb, "%s\t}\n", indent)
}

// writeNullableNumericFilterCases generates switch cases for nullable numeric filters
func (g *Generator) writeNullableNumericFilterCases(sb *strings.Builder, columnName, indent, typeName string) {
	// typeName is already correctly cased (e.g., "UInt32", "Int64")
	typePrefix := "Nullable" + typeName

	// Generate all the numeric filter cases with Nullable prefix
	fmt.Fprintf(sb, "%scase *%sFilter_Eq:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Ne:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", filter.Lt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Lte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", filter.Lte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gt:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", filter.Gt)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Gte:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", filter.Gte)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_Between:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", filter.Between.Min, filter.Between.Max.GetValue())\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_In:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", %sSliceToInterface(filter.In.Values))\n", indent, columnName, typeName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *%sFilter_NotIn:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", %sSliceToInterface(filter.NotIn.Values))\n", indent, columnName, typeName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	// Plus null cases
	fmt.Fprintf(sb, "%scase *%sFilter_IsNull:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddIsNullCondition(\"%s\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%sFilter_IsNotNull:\n", indent, typePrefix)
	fmt.Fprintf(sb, "%s\tqb.AddIsNotNullCondition(\"%s\")\n", indent, columnName)
}

// writeBoolFilterCases generates switch cases for BoolFilter using QueryBuilder
func (g *Generator) writeBoolFilterCases(sb *strings.Builder, columnName, indent string) {
	fmt.Fprintf(sb, "%scase *BoolFilter_Eq:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *BoolFilter_Ne:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)
}

// writeNullableBoolFilterCases generates switch cases for NullableBoolFilter using QueryBuilder
func (g *Generator) writeNullableBoolFilterCases(sb *strings.Builder, columnName, indent string) {
	fmt.Fprintf(sb, "%scase *NullableBoolFilter_Eq:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", filter.Eq)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableBoolFilter_Ne:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", filter.Ne)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableBoolFilter_IsNull:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddIsNullCondition(\"%s\")\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *NullableBoolFilter_IsNotNull:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddIsNotNullCondition(\"%s\")\n", indent, columnName)
}

// writeMapStringStringFilterCases generates switch cases for MapStringStringFilter using QueryBuilder
func (g *Generator) writeMapStringStringFilterCases(sb *strings.Builder, columnName, indent string) {
	fmt.Fprintf(sb, "%scase *MapStringStringFilter_KeyValue:\n", indent)
	fmt.Fprintf(sb, "%s\t// Handle key-value filter with string values\n", indent)
	fmt.Fprintf(sb, "%s\tswitch kvFilter := filter.KeyValue.ValueFilter.Filter.(type) {\n", indent)
	fmt.Fprintf(sb, "%s\tcase *StringFilter_Eq:\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \"=\", kvFilter.Eq)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *StringFilter_Ne:\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \"!=\", kvFilter.Ne)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *StringFilter_Like:\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyLikeCondition(\"%s\", filter.KeyValue.Key, kvFilter.Like)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *StringFilter_StartsWith:\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyLikeCondition(\"%s\", filter.KeyValue.Key, kvFilter.StartsWith + \"%%\")\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *StringFilter_EndsWith:\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyLikeCondition(\"%s\", filter.KeyValue.Key, \"%%\" + kvFilter.EndsWith)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *StringFilter_Contains:\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyLikeCondition(\"%s\", filter.KeyValue.Key, \"%%\" + kvFilter.Contains + \"%%\")\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *MapStringStringFilter_HasKey:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddMapContainsCondition(\"%s\", filter.HasKey)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *MapStringStringFilter_NotHasKey:\n", indent)
	fmt.Fprintf(sb, "%s\tqb.AddNotMapContainsCondition(\"%s\", filter.NotHasKey)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *MapStringStringFilter_HasAnyKey:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.HasAnyKey.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapContainsAnyCondition(\"%s\", filter.HasAnyKey.Values)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *MapStringStringFilter_HasAllKeys:\n", indent)
	fmt.Fprintf(sb, "%s\tif len(filter.HasAllKeys.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tfor _, key := range filter.HasAllKeys.Values {\n", indent)
	fmt.Fprintf(sb, "%s\t\t\tqb.AddMapContainsCondition(\"%s\", key)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t\t}\n", indent)
	fmt.Fprintf(sb, "%s\t}\n", indent)
}

// writeDateTimeFilterCases generates switch cases for DateTime filters with fromUnixTimestamp conversion
func (g *Generator) writeDateTimeFilterCases(sb *strings.Builder, columnName, filterType, indent string) {
	// DateTime fields are stored as UInt32 (Unix timestamps) in protobuf
	// but need to be converted to DateTime in ClickHouse queries
	// We wrap the column with fromUnixTimestamp() function

	switch filterType {
	case "UInt32Filter":
		// Standard DateTime (stored as UInt32)
		// Wrap values in DateTimeValue to trigger fromUnixTimestamp conversion

		fmt.Fprintf(sb, "%scase *UInt32Filter_Eq:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", DateTimeValue{filter.Eq})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *UInt32Filter_Ne:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", DateTimeValue{filter.Ne})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *UInt32Filter_Lt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", DateTimeValue{filter.Lt})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *UInt32Filter_Lte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", DateTimeValue{filter.Lte})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *UInt32Filter_Gt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", DateTimeValue{filter.Gt})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *UInt32Filter_Gte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", DateTimeValue{filter.Gte})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *UInt32Filter_Between:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", DateTimeValue{filter.Between.Min}, DateTimeValue{filter.Between.Max.GetValue()})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *UInt32Filter_In:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.In.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.In.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTimeValue{v}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)

		fmt.Fprintf(sb, "%scase *UInt32Filter_NotIn:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.NotIn.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.NotIn.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTimeValue{v}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)
	case "Int64Filter":
		// DateTime64 (stored as Int64 - toUnixTimestamp64Micro returns Int64)
		fmt.Fprintf(sb, "%scase *Int64Filter_Eq:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", DateTime64Value{uint64(filter.Eq)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *Int64Filter_Ne:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", DateTime64Value{uint64(filter.Ne)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *Int64Filter_Lt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", DateTime64Value{uint64(filter.Lt)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *Int64Filter_Lte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", DateTime64Value{uint64(filter.Lte)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *Int64Filter_Gt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", DateTime64Value{uint64(filter.Gt)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *Int64Filter_Gte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", DateTime64Value{uint64(filter.Gte)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *Int64Filter_Between:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", DateTime64Value{uint64(filter.Between.Min)}, DateTime64Value{uint64(filter.Between.Max.GetValue())})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *Int64Filter_In:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.In.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.In.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTime64Value{uint64(v)}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)

		fmt.Fprintf(sb, "%scase *Int64Filter_NotIn:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.NotIn.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.NotIn.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTime64Value{uint64(v)}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)
	case "NullableUInt32Filter":
		// Nullable DateTime (stored as NullableUInt32)
		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_IsNull:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddIsNullCondition(\"%s\")\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_IsNotNull:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddIsNotNullCondition(\"%s\")\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_Eq:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", DateTimeValue{filter.Eq})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_Ne:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", DateTimeValue{filter.Ne})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_Lt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", DateTimeValue{filter.Lt})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_Lte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", DateTimeValue{filter.Lte})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_Gt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", DateTimeValue{filter.Gt})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_Gte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", DateTimeValue{filter.Gte})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_Between:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", DateTimeValue{filter.Between.Min}, DateTimeValue{filter.Between.Max.GetValue()})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_In:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.In.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.In.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTimeValue{v}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)

		fmt.Fprintf(sb, "%scase *NullableUInt32Filter_NotIn:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.NotIn.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.NotIn.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTimeValue{v}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)

	case "NullableInt64Filter":
		// Nullable DateTime64 (stored as NullableInt64)
		fmt.Fprintf(sb, "%scase *NullableInt64Filter_IsNull:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddIsNullCondition(\"%s\")\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_IsNotNull:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddIsNotNullCondition(\"%s\")\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_Eq:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"=\", DateTime64Value{uint64(filter.Eq)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_Ne:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"!=\", DateTime64Value{uint64(filter.Ne)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_Lt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<\", DateTime64Value{uint64(filter.Lt)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_Lte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \"<=\", DateTime64Value{uint64(filter.Lte)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_Gt:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">\", DateTime64Value{uint64(filter.Gt)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_Gte:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddCondition(\"%s\", \">=\", DateTime64Value{uint64(filter.Gte)})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_Between:\n", indent)
		fmt.Fprintf(sb, "%s\tqb.AddBetweenCondition(\"%s\", DateTime64Value{uint64(filter.Between.Min)}, DateTime64Value{uint64(filter.Between.Max.GetValue())})\n", indent, columnName)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_In:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.In.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.In.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.In.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTime64Value{uint64(v)}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)

		fmt.Fprintf(sb, "%scase *NullableInt64Filter_NotIn:\n", indent)
		fmt.Fprintf(sb, "%s\tif len(filter.NotIn.Values) > 0 {\n", indent)
		fmt.Fprintf(sb, "%s\t\tconverted := make([]interface{}, len(filter.NotIn.Values))\n", indent)
		fmt.Fprintf(sb, "%s\t\tfor i, v := range filter.NotIn.Values {\n", indent)
		fmt.Fprintf(sb, "%s\t\t\tconverted[i] = DateTime64Value{uint64(v)}\n", indent)
		fmt.Fprintf(sb, "%s\t\t}\n", indent)
		fmt.Fprintf(sb, "%s\t\tqb.AddNotInCondition(\"%s\", converted)\n", indent, columnName)
		fmt.Fprintf(sb, "%s\t}\n", indent)
	}
}

// writeMapStringNumericFilterCases generates switch cases for Map(String, Numeric) filters
func (g *Generator) writeMapStringNumericFilterCases(sb *strings.Builder, columnName, indent, numericType string) {
	filterType := fmt.Sprintf("MapString%sFilter", numericType)

	fmt.Fprintf(sb, "%scase *%s_KeyValue:\n", indent, filterType)
	fmt.Fprintf(sb, "%s\t// Handle key-value filter with %s values\n", indent, numericType)
	fmt.Fprintf(sb, "%s\tswitch kvFilter := filter.KeyValue.ValueFilter.Filter.(type) {\n", indent)
	fmt.Fprintf(sb, "%s\tcase *%sFilter_Eq:\n", indent, numericType)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \"=\", kvFilter.Eq)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *%sFilter_Ne:\n", indent, numericType)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \"!=\", kvFilter.Ne)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *%sFilter_Lt:\n", indent, numericType)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \"<\", kvFilter.Lt)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *%sFilter_Lte:\n", indent, numericType)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \"<=\", kvFilter.Lte)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *%sFilter_Gt:\n", indent, numericType)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \">\", kvFilter.Gt)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *%sFilter_Gte:\n", indent, numericType)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyCondition(\"%s\", filter.KeyValue.Key, \">=\", kvFilter.Gte)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\tcase *%sFilter_Between:\n", indent, numericType)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapKeyBetweenCondition(\"%s\", filter.KeyValue.Key, kvFilter.Between.Min, kvFilter.Between.Max)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *%s_HasKey:\n", indent, filterType)
	fmt.Fprintf(sb, "%s\tqb.AddMapContainsCondition(\"%s\", filter.HasKey)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%s_NotHasKey:\n", indent, filterType)
	fmt.Fprintf(sb, "%s\tqb.AddNotMapContainsCondition(\"%s\", filter.NotHasKey)\n", indent, columnName)

	fmt.Fprintf(sb, "%scase *%s_HasAnyKey:\n", indent, filterType)
	fmt.Fprintf(sb, "%s\tif len(filter.HasAnyKey.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tqb.AddMapContainsAnyCondition(\"%s\", filter.HasAnyKey.Values)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t}\n", indent)

	fmt.Fprintf(sb, "%scase *%s_HasAllKeys:\n", indent, filterType)
	fmt.Fprintf(sb, "%s\tif len(filter.HasAllKeys.Values) > 0 {\n", indent)
	fmt.Fprintf(sb, "%s\t\tfor _, key := range filter.HasAllKeys.Values {\n", indent)
	fmt.Fprintf(sb, "%s\t\t\tqb.AddMapContainsCondition(\"%s\", key)\n", indent, columnName)
	fmt.Fprintf(sb, "%s\t\t}\n", indent)
	fmt.Fprintf(sb, "%s\t}\n", indent)
}
